# 排序算法

![sort algorithms](../../../resources/images/sort-algorithms.jpeg)

**排序算法是一种将一组数据按照特定顺序进行排列的算法。**

排序算法是计算机基本问题之一，它在各个领域都有广泛的应用，几乎是现代计算机底层原理的基石，是研究算法的必经之路！

排序算法多种多样，各有特点，主要有7中常见的排序算法：冒泡排序（Bubble Sort）、插入排序（Insertion Sort）、选择排序（Selection Sort）、快速排序（Quick Sort）、归并排序（Merge Sort）、希尔排序（Shell Sort）、桶排序（Bucket Sort）。

下面我们将逐个了解每个算法的特点和过程！

## 冒泡排序（Bubble Sort）

![bubble sorting](../../../resources/images/bubble-sorting.png)

冒泡排序算法是一种简单的排序算法，它重复地比较相邻的两个元素，并按照顺序交换它们，直到整个序列有序为止。

### 冒泡排序的实现过程如下：
1. 从序列的第一个元素开始，依次比较相邻的两个元素，如果它们的顺序不正确，则交换它们的位置，将较大（或较小）的元素“冒泡”到最后（或最前）。
2. 经过第一轮比较后，最大（或最小）的元素已经位于序列的最后（或最前）位置。
3. 重复进行第1和第2步，但每次比较的元素数量都减少1，直到所有元素都排好序。

### 冒泡排序的时间复杂度
冒泡排序的时间复杂度为O(n^2)，其中n是待排序序列的长度。最好情况下，序列已经有序，只需要进行一次扫描，时间复杂度为O(n)。最坏情况下，序列逆序，需要进行n-1轮比较和交换，时间复杂度为O(n^2)。平均情况下，冒泡排序的时间复杂度也为O(n^2)。

### 冒泡排序的优缺点及应用场景
冒泡排序的优点是实现简单，易于理解和编写。同时，冒泡排序是一种稳定的排序算法，相等元素的相对顺序在排序后不会改变。

然而，冒泡排序的缺点是效率较低，尤其在处理大规模数据时。由于需要多次比较和交换，冒泡排序的性能较差。对于逆序序列或基本有序的序列，冒泡排序仍然会进行多余的比较和交换操作，导致性能浪费。

综上所述，冒泡排序适用于数据规模较小或基本有序的情况，对于大规模数据或要求高效排序的场景，更适合选择其他高效的排序算法。

## 选择排序（Selection Sort）

![selection-sort](../../../resources/images/selection-sort.png)

选择排序算法是一种简单的排序算法，它每次从待排序序列中选择最小（或最大）的元素，并将其放置在已排序序列的末尾（或开头），直到整个序列有序为止。

### 选择排序的实现过程如下：
1. 找到序列中最小（或最大）的元素，并将其与序列的第一个元素交换位置。
2. 在剩余的未排序序列中找到最小（或最大）的元素，并将其与序列的第二个元素交换位置。
3. 依次类推，每次从未排序序列中选择最小（或最大）的元素，并将其与已排序序列的下一个位置交换，直到所有元素都排好序。

### 选择排序的时间复杂度
选择排序的时间复杂度为O(n^2)，其中n是待排序序列的长度。无论序列的初始状态如何，选择排序都需要进行n-1轮比较和交换操作。每一轮中，需要在未排序序列中选择最小（或最大）的元素，然后与已排序序列的下一个位置交换。这种固定的比较和交换操作导致选择排序的时间复杂度始终为O(n^2)。

### 选择排序的优缺点及应用场景
选择排序的优点是实现简单，易于理解和编写。它是一种稳定的排序算法，相等元素的相对顺序在排序后不会改变。

然而，选择排序的缺点是效率较低，尤其在处理大规模数据时。由于需要多次比较和交换，选择排序的性能较差。与冒泡排序类似，选择排序在每一轮中只能确定一个元素的最终位置，而不是一次性确定整个序列的有序性。

综上所述，选择排序适用于数据规模较小或基本有序的情况，对于大规模数据或要求高效排序的场景，更适合选择其他高效的排序算法。

## 插入排序（Insertion Sort）

![Insertion Sort](../../../resources/images/Insertion-Sort.png)

插入排序算法是一种简单直观的排序算法，它将待排序序列分为已排序和未排序两部分，每次从未排序部分中选择一个元素插入到已排序部分的适当位置，直到所有元素都被插入为止。

### 插入排序的实现过程如下：
1. 从第二个元素开始，将其视为已排序部分。
2. 依次将未排序部分的元素与已排序部分的元素进行比较，找到合适的位置插入。
3. 插入元素后，已排序部分长度增加一，并将插入位置后的元素向后移动一个位置。
4. 重复上述步骤，直到所有元素都被插入到合适的位置。

### 插入排序的时间复杂度
插入排序的时间复杂度为O(n^2)，其中n是待排序序列的长度。在最坏情况下，即待排序序列逆序时，插入排序需要进行大量的比较和移动操作。每次插入一个元素时，需要与已排序部分的元素逐个比较并移动，因此平均情况下每个元素需要比较和移动的次数都是线性的，导致总的时间复杂度为O(n^2)。

### 插入排序的优缺点及应用场景
插入排序的优点是实现简单，易于理解和编写。它是一种稳定的排序算法，相等元素的相对顺序在排序后不会改变。另外，插入排序对于部分有序的序列具有较好的性能。

然而，插入排序的缺点是对于大规模乱序的数据排序效率较低。在每次插入一个元素时，需要与已排序部分的元素逐个比较和移动，因此插入排序的性能与待排序序列的初始状态密切相关。当数据规模较大且乱序程度较高时，插入排序的性能较差。

综上所述，插入排序适用于数据规模较小或基本有序的情况，对于大规模乱序的数据或要求高效排序的场景，更适合选择其他高效的排序算法。

## 快速排序（Quick Sort）

![Quick Sort](../../../resources/images/Quick-Sort.png)

快速排序算法是一种常用的排序算法，它基于分治法的思想，通过将待排序序列分割成较小的子序列，然后分别对子序列进行排序，最终将整个序列排序完成。

### 快速排序的实现过程如下：
1. 选择一个元素作为基准值（通常选择第一个元素）。
2. 将序列分割成两部分，使得左边的元素都小于等于基准值，右边的元素都大于等于基准值。这个过程称为分区操作（partition）。
3. 对左右两个子序列分别进行递归调用快速排序。
4. 重复上述步骤，直到子序列的长度为1或为空。

### 快速排序的时间复杂度
快速排序的时间复杂度为平均情况下的O(nlogn)，其中n是待排序序列的长度。在最坏情况下，即每次划分只能将序列划分成长度为1和n-1的两个子序列时，快速排序的时间复杂度为O(n^2)。然而，通过合理选择基准值和优化分区操作，可以降低最坏情况下的发生概率。

### 快速排序的优缺点及应用场景
快速排序的优点是实现简单、适用范围广，并且在平均情况下具有较好的性能。它是一种原地排序算法，不需要额外的存储空间。快速排序也是一种稳定的排序算法，相等元素的相对顺序在排序后不会改变。

然而，快速排序的缺点是在最坏情况下性能较差，并且对于包含大量重复元素的序列，可能出现分割不均匀的情况，导致递归调用的层数过多，影响性能。为了解决这个问题，可以采用随机选择基准值或者使用三数取中法等方法来选择基准值，以提高分割的均匀性。

综上所述，快速排序适用于大规模乱序的数据排序，对于较小规模的数据或基本有序的序列，其他算法可能更为适合。
